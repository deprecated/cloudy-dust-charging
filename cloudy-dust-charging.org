* Cloudy models of dust grain charging around luminous stars
+ The aim is to find \phi as a function of ionization parameter (and other parameters)
  + Mainly for OB stars, but may also try RSG/AGB case
+ This can then be used to study gas-grain decoupling in bow shocks
* DONE Initial tests
CLOSED: [2018-03-16 Fri 10:55]
+ [X] Write an input file by hand
  + Start with something from test suite?
  + First attempt is [[file:models/test-dust.in]]
+ [X] Run it and see what output we need to save
  #+BEGIN_SRC sh :eval no
  export D=~/Work/CLOUDY/cloudy/source
  cd models
  $D/cloudy.exe -p test-dust
  #+END_SRC


* TODO Production runs
+ [X] Decide which approach to use?
  1. Python script to write multiple input, run with ~make -j 8~
  2. Work out how to use Cloudy grid command (need to install MPI?)
+ Do it


* Expand template for input files
#+BEGIN_SRC python
  from textwrap import dedent
  import numpy as np

  LSUN = 3.82e33

  def star_input(id_, L4, T3, log_g):
      s = f"# {id_} star" + "\n"
      s += f"# T_eff = {1e3*T3:.0f} K, L = {1e4*L4:.2e} L_sun, log(g) = {log_g:.2f}" + "\n"
      s += f"table star tlusty OBstar 3-dim {1e3*T3:.0f} {log_g} 0.0" + "\n"
      s += f"luminosity {np.log10(LSUN*1e4*L4):.2f}" + "\n"
      return s

  def hden_input(hden):
      return f"hden {hden:.2f} # density of {10**hden} pcc" + "\n"

  def file_stem(hden, id_):
      return f"dustrad-n{int(hden):02d}-{id_}" 

  def intro_input(hden, id_):
      s = f"title Dust radiative acceleration: star {id_}, density {10**hden} pcc" + "\n"
      s += f"set save prefix \"{file_stem(hden, id_)}\"" + "\n"
      return s

  stars = [
      # id_   L4     T3    log_g
      ["MS10", 0.63, 25.2, 4.2],
      ["MS20", 5.45, 33.9, 4.2],
      ["MS40", 22.2, 42.5, 4.2],
      ["BSG",  30.2, 23.5, 3.4],
  ]

  def radius_input(L4, hden):
      # Scale R_in to give same F_bol / N as the MS10 model with hden=1
      R_in = 3e16 * np.sqrt((L4/0.63) * 10**(1.0 - hden))
      s = f"# Start close in: {R_in/3.085677582e18:.5f} pc" + "\n"
      s += f"radius {np.log10(R_in)}" + "\n"
      return s


  outro_input = dedent("""\
  # Go into PDR a bit
  stop temperature 4000 K linear
  iterate
  sphere
  grains ism function sublimation
  abundances HII region no grains
  cosmic ray background
  cmb
  table ism 
  # save all the output we want
  save overview last ".ovr"
  save physical conditions last ".phys"
  save continuum last ".cont"
  save radius last ".rad"
  save grain abundance last ".gabun"
  save grain charge last ".gcharge"
  save grain continuum last ".gcont"
  save grain drift velocity last ".gdrift"
  save grain potential last ".gpot"
  save grain temperature last ".gtemp"
  """)

  for hden in 0.0, 1.0, 2.0, 3.0, 4.0:
      for id_, L4, T3, log_g in stars:
          cloudy_input = (intro_input(hden, id_)
                          + star_input(id_, L4, T3, log_g)
                          + hden_input(hden)
                          + radius_input(L4, hden)
                          + outro_input)
          file_name = f"models/{file_stem(hden, id_)}.in"
          with open(file_name, "w") as f:
              f.write(cloudy_input)
#+END_SRC

#+RESULTS:
: None


* Look at dust 

* Graphs

** Utility library for reading model
#+BEGIN_SRC python :tangle cloudytab.py
  from astropy.table import Table
  import glob

  # File extensions that might be present, but which are NOT Cloudy save files
  IGNORE_EXTS = ["pdf", "png", "jpg"]

  class CloudyModel(object):
      """Lightweight wrapper for output from Cloudy run 

      For example:

      >>> from cloudytab import CloudyModel
      >>> m = CloudyModel("myfolder/mymodel")

      `m.files` contains a list of all the files that were found: 
                `['myfolder/mymodel.in', 'myfolder/mymodel.ovr', ETC]`

      `m.data` contains dict of astropy.Table's, one for each save file:
                `{'ovr': <Table length=289> ..., ETC}`

      `m.io['in']` and `m.io['out']` contain the input and output streams
      """
      def __init__(self, prefix):
          self.files = glob.glob(prefix + ".*")
          self.data = {}
          self.io = {}
          for file_ in self.files:
              saveid = file_.split(".")[-1]
              if saveid in IGNORE_EXTS:
                  # Figure files, etc need to be skipped
                  pass
              elif saveid in ["in", "out"]:
                  # Special case of input and output files
                  with open(file_) as f:
                      # Just save the whole file as a string
                      self.io[saveid] = f.read()
              else:
                  # Assume all else are save files
                  try:
                      self.data[saveid] = Table.read(
                          file_, delimiter="\t",
                          format="ascii.commented_header")
                  except UnicodeDecodeError:
                      # Binary files can raise this error - ignore them
                      pass

#+END_SRC


** Try plotting a bunch of models: potential versus ionization parameter
+ Estimate ionization parameter from H neutral fraction 
+ Do a single star at a time, since there may be a secondary dependence on the spectral shape
#+name: phi-vs-ipar
#+header: :var STAR="MS10" GRAIN="sil-orion01"
#+BEGIN_SRC python :return figfile :results file
  import glob
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  figfile = f"phi-ipar-{STAR}-{GRAIN}.pdf"

  infiles = glob.glob(f"models/dustrad-*-{STAR}.in")
  models = []
  for infile in infiles:
      prefix = infile.replace(".in", "")
      modelid = prefix.replace("models/dustrad-", "")  # e.g., n03-MS10
      models.append([modelid, CloudyModel(prefix)])


  fig, ax = plt.subplots()
  for label, m in sorted(models):
      # Ionization parameter, estimated as x^2 / (1 - x)
      # (Initially, we neglect correction for alpha(T) and sigma(tau))
      ipar = m.data["ovr"]["HII"]**2 / m.data["ovr"]["HI"]
      # Grain potential divided by kT
      gpot = m.data["gpot"][GRAIN]*u.eV / (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)

      ax.plot(ipar, gpot, label=label)
  ax.axvspan(0.0111, 8.1, color='k', alpha=0.1)    # x = 0.1 -> 0.9
  ax.axhspan(-1.0, 1.0, color='k', alpha=0.1)      # |phi| < 1
  ax.legend(title=GRAIN)
  ax.set(
      xscale='log',
      yscale='symlog',
      xlabel="Ionization parameter",
      ylabel="Grain potential / k T",
      xlim=[3e-5, 3e6],
      ylim=[-5.0, 50.0],
  )
  sns.despine()

  fig.savefig(figfile)
#+END_SRC

#+RESULTS: phi-vs-ipar
[[file:phi-ipar-MS10-sil-orion01.pdf]]

#+call: phi-vs-ipar("MS10", "sil-orion10")

#+RESULTS:
[[file:phi-ipar-MS10-sil-orion10.pdf]]

#+call: phi-vs-ipar("MS10", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-MS10-gra-orion10.pdf]]

#+call: phi-vs-ipar("MS40", "sil-orion01")

#+RESULTS:
[[file:phi-ipar-MS40-sil-orion01.pdf]]

#+call: phi-vs-ipar("MS40", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-MS40-gra-orion10.pdf]]

#+call: phi-vs-ipar("BSG", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-BSG-gra-orion10.pdf]]


#+name: phi-vs-ipar-allgrain
#+header: :var STAR="MS10" 
#+BEGIN_SRC python :return figfile :results file
  import glob
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  figfile = f"phi-ipar-{STAR}-allgrain.pdf"

  infiles = glob.glob(f"models/dustrad-*-{STAR}.in")
  models = []
  for infile in infiles:
      prefix = infile.replace(".in", "")
      modelid = prefix.replace("models/dustrad-", "")  # e.g., n03-MS10
      models.append([modelid, CloudyModel(prefix)])

  sns.set_color_codes("deep")
  fig, ax = plt.subplots()
  colors = sns.color_palette(palette="magma_r", n_colors=len(models))
  fastlabel = r"$w_\mathrm{drift} > 10$ km/s"
  fastishlabel = r"$w_\mathrm{drift} > 1$ km/s"
  for color, [label, m] in zip(colors, sorted(models)):
      # Ionization parameter, estimated as x^2 / (1 - x)
      # (Initially, we neglect correction for alpha(T) and sigma(tau))
      ipar = m.data["ovr"]["HII"]**2 / m.data["ovr"]["HI"]
      for grain in m.data["gpot"].colnames[1:]:
          # Grain potential divided by kT
          gpot = m.data["gpot"][grain]*u.eV / (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)
          ls = '--' if grain.startswith("gra") else '-'
          # Only plot where grains are not sublimated
          mm = m.data["gabun"][grain] >= 0.3*m.data["gabun"][grain].max()
          ax.plot(ipar[mm], gpot[mm], alpha=0.8, color=color, ls=ls, lw=0.4, label=label)
          m2 = m.data["gdrift"][grain] >= 10.0
          m1 = (m.data["gdrift"][grain] >= 1.0) & ~m2
          ax.scatter(ipar[m2 & mm], gpot[m2 & mm], label=fastlabel,
                     marker='.', s=60, alpha=0.8, color='c', edgecolors='none')
          ax.scatter(ipar[m1 & mm], gpot[m1 & mm], label=fastishlabel,
                     marker='.', s=40, alpha=0.8, color='b', edgecolors='none')
          label = '_nolabel_' # Only label first grain component
          fastlabel = '_nolabel_' 
          fastishlabel = '_nolabel_' 

  ax.legend()
  ax.axvspan(0.0111, 8.1, color='k', alpha=0.1)    # x = 0.1 -> 0.9
  ax.axhspan(-1.0, 1.0, color='k', alpha=0.1)      # |phi| < 1
  #ax.legend(title=GRAIN)
  ax.text(0.0015, -3.0, "PDR", ha="center")
  ax.text(0.3, -3.0, "Ionization\nfront", ha="center")
  ax.text(200, -3.0, "H II region", ha="center")
  ax.set(
      xscale='log',
      yscale='symlog',
      xlabel="Hydrogen ionization: $x^{2} / (1 - x)$",
      ylabel="Grain potential / $k T$",
      xlim=[3e-4, 3e8],
      ylim=[-5.0, 50.0],
  )
  sns.despine()

  fig.savefig(figfile)
#+END_SRC

#+RESULTS: phi-vs-ipar-allgrain
[[file:phi-ipar-MS10-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("MS20")

#+RESULTS:
[[file:phi-ipar-MS20-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("MS40")

#+RESULTS:
[[file:phi-ipar-MS40-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("BSG")

#+RESULTS:
[[file:phi-ipar-BSG-allgrain.pdf]]



** Plot drift velocity versus rad/gas pressure ratio

+ First of all, look at \tau_\nu in the final zone by using the continuum

#+name: tau-plot
#+header: :var DENID="n00"
#+BEGIN_SRC python :return pltfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'tau-{DENID}.pdf'
  fig, ax = plt.subplots()

  for star in "MS10", "MS20", "MS40", "BSG":
      prefix = f"dustrad-{DENID}-{star}"
      m = CloudyModel(f'models/{prefix}')
      nu = m.data['cont']['Cont  nu']
      nuFnu_inc = m.data['cont']['incident'] 
      nuFnu_trans = m.data['cont']['trans'] 
      nuFnu_tot = m.data['cont']['total'] 
      tau_nu = -np.log(m.data['cont']['trans'] / m.data['cont']['incident'] )
      ax.plot(nu, tau_nu, label=star)

  ax.legend(title=DENID)
  ax.axvspan(912.0/2000.0, 1.0, color='0.9')
  ax.axvspan(1.0, 4.0, color='0.95')

  ax.set(
      xlim=[0.05, 4.0],
      ylim=[0.004, 200.0],
      yscale='log',
      xscale='log',
      xlabel='Photon energy, Rydberg',
      ylabel=r'$\tau_{\nu}$',
  )

  fig.savefig(pltfile)

#+END_SRC

#+RESULTS: tau-plot
[[file:tau-n00.pdf]]

#+call: tau-plot("n04")

#+RESULTS:
[[file:tau-n04.pdf]]

Then we use these to find the local fluxes and determine radiation pressure

#+name: write-flux-tables
#+BEGIN_SRC python 
  import numpy as np
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  stars = [
      ["MS10", 0.63],
      ["MS20", 5.45],
      ["MS40", 22.2],
      ["BSG", 30.2]
  ]

  denids = [f"n0{_}" for _ in range(5)]
  for star, L4 in stars:
      L = 1e4*3.82e33*L4
      for denid in denids:
          # Read model 
          prefix = f"dustrad-{denid}-{star}"
          m = CloudyModel(f'models/{prefix}')

          # Find tau
          nu = m.data['cont']['Cont  nu']
          nuFnu_inc = m.data['cont']['incident'] 
          nuFnu_trans = m.data['cont']['trans']
          tau_nu = -np.log(m.data['cont']['trans'] / m.data['cont']['incident'] )

          # F_nu spectrum that is normalized to unit integral
          Fnu_0 = nuFnu_inc / nu
          Fnu_0 /= np.trapz(Fnu_0, nu)

          # Masks for non-ionizing and ionizing radiation
          mfuv = nu < 1.0
          meuv = ~mfuv

          # Scale of tau with radius, normalized on [0, 1]
          # For FUV, it is just column density - proprtional to depth at constant density
          depth = m.data['ovr']['depth']
          tau_rscale_fuv = depth / depth[-1]
          # For EUV, it is neutral column density
          nzones = len(depth)
          nH0 = m.data['ovr']['hden']*m.data['ovr']['HI']
          tau_rscale_euv = np.array([np.trapz(nH0[:i], depth[:i]) for i in range(nzones)])
          tau_rscale_euv /= tau_rscale_euv[-1]
        
          # Extinction factor e^(-tau) as function of depth for fuv and euv
          extinct_fuv = np.array(
              [np.trapz(Fnu_0[mfuv]*np.exp(-tau_nu[mfuv]*tau_rscale_fuv[i]), nu[mfuv])
               for i in range(nzones)])
          extinct_euv = np.array(
              [np.trapz(Fnu_0[meuv]*np.exp(-tau_nu[meuv]*tau_rscale_euv[i]), nu[meuv])
               for i in range(nzones)])
          radius = m.data['rad']['radius']
          # Flux in each band
          F_fuv = L * extinct_fuv / (4*np.pi*radius**2)
          F_euv = L * extinct_euv / (4*np.pi*radius**2)
          F_bol = F_fuv + F_euv

          tab = Table(
              [radius, F_bol, F_fuv, F_euv, extinct_fuv, extinct_euv, tau_rscale_fuv, tau_rscale_euv],
              names=('R', 'F', 'F_F', 'F_E', 'E_F', 'E_E', 'T_F', 'T_E')
          )
          tab.write(f'models/{prefix}.flux',
                    format='ascii.commented_header',
                    formats={_: "%.4g" for _ in tab.colnames},
                    delimiter='\t', overwrite=True)
        
#+END_SRC

#+RESULTS: write-flux-tables
: None

This works OK, but it has the disadvantage that it ignores the dust extinction in the EUV


#+name: fluxes-plot
#+header: :var PREFIX="n00-MS10"
#+BEGIN_SRC python :return pltfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'fluxes-{PREFIX}.pdf'
  fig, ax = plt.subplots()

  F_habing = 1.6e-3

  prefix = f"dustrad-{PREFIX}"
  m = CloudyModel(f'models/{prefix}')
  R = m.data['flux']['R'] / 3.085677582e18
  hden = m.data['ovr']['hden']
  ax.plot(R, m.data['flux']['F_F'] / (F_habing*hden), label='G(FUV) / n')
  ax.plot(R, m.data['flux']['F_E'] / (F_habing*hden), label='G(EUV) / n')


  ax.legend(title=PREFIX)

  ax.set(
      yscale='log',
      xscale='log',
      xlabel='Radius, pc',
      ylabel=r'Flux',
      ylim=[2e-5, 2e5],
      xlim=[0.8*R[0], 3000*R[0]],
  )

  fig.savefig(pltfile)

#+END_SRC

#+RESULTS: fluxes-plot
[[file:fluxes-n00-MS10.pdf]]

#+call: fluxes-plot("n04-MS10")

#+RESULTS:
[[file:fluxes-n04-MS10.pdf]]

#+call: fluxes-plot("n01-MS40")

#+RESULTS:
[[file:fluxes-n01-MS40.pdf]]

#+call: fluxes-plot("n04-MS40")

#+RESULTS:
[[file:fluxes-n04-MS40.pdf]]


#+name: drift-pratio-plot
#+BEGIN_SRC python :return pltfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'drift-pratio.pdf'
  fig, ax = plt.subplots()

  F_habing = 1.6e-3
  light_speed = 2.99792458e10
  kB = 1.3806503e-16
  stars = [
      ["MS10", 0.63],
      ["MS20", 5.45],
      ["MS40", 22.2],
      ["BSG", 30.2]
  ]

  denids = [f"n0{_}" for _ in range(5)]
  for star, L4 in stars:
      L = 1e4*3.82e33*L4
      for denid in denids:
          # Read model 
          prefix = f"dustrad-{denid}-{star}"
          m = CloudyModel(f'models/{prefix}')

          Prad = m.data['flux']['F_F']/light_speed
          hden = m.data['ovr']['hden']
          eden = m.data['ovr']['eden']
          Te = m.data['ovr']['Te']
          Pgas = (hden + eden)*kB*Te
          for grain in m.data['gdrift'].colnames[1:]:
              ax.plot(Prad/Pgas, m.data['gdrift'][grain], alpha=0.1)

  ax.set(
      yscale='log',
      xscale='log',
      xlabel='Prad / Pgas',
      ylabel=r'V drift',
      xlim=[1.0e-3, 4e3],
  )

  fig.savefig(pltfile)

#+END_SRC

#+RESULTS: drift-pratio-plot
[[file:drift-pratio.pdf]]

** Multi-panels for a single run
:PROPERTIES:
:ID:       7081EFE5-65A5-4662-B298-B236BC13AC40
:END:
#+name: make-plot
#+header: :var PREFIX="test-dust-tlusty"
#+BEGIN_SRC python :return pltfile :results file :exports both
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'models/{PREFIX}.png'
  m = CloudyModel(f'models/{PREFIX}')

  sns.set_palette("Reds_d", n_colors=10)
  sns.set_color_codes()
  fig, axes = plt.subplots(5, 1, sharex=True, figsize=(6, 9))
  radius_pc = (m.data["rad"]["radius"])*u.cm.to(u.pc)
  kT_eV = (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)

  for gtype in m.data["gdrift"].colnames[1:]:
      if gtype.startswith('sil'):
          style = dict(lw=1.0, alpha=0.6, ls='-')
      else:
          style = dict(lw=0.6, alpha=1.0, ls='--')
      axes[-1].plot(radius_pc, m.data["gdrift"][gtype], label=gtype, **style)
      axes[-2].plot(radius_pc, m.data["gpot"][gtype], label=gtype, **style)
      axes[-3].plot(radius_pc, m.data["gabun"][gtype], label=gtype, **style)
      mm = m.data["gabun"][gtype] >= 0.3*m.data["gabun"][gtype].max()
      axes[0].plot(radius_pc[mm], m.data["gtemp"][gtype][mm], label=gtype, **style)

  axes[0].plot(radius_pc, m.data["ovr"]["Te"], color='g')
  axes[1].plot(radius_pc, m.data["phys"]["accel"], color='r')
  axes[-3].plot(radius_pc, m.data["gabun"]["total"], color='g', lw=1.5)
  abun_max = m.data["gabun"]["total"].max()

  axes[-2].plot(radius_pc, kT_eV)
  axes[-2].axhline(0.0, color='0.5', lw=0.5)
  axes[-3].legend(ncol=2, loc="lower right", fontsize="xx-small")
  axes[0].set(
      xscale="log",
      yscale="log",
      ylabel="Temperature, K",
      ylim=[0, None],
  )
  axes[1].set(
      yscale="log",
      ylabel="Acceleration",
  )
  axes[-3].set(
      xscale="log",
      yscale="log",
      ylabel="Grain abundance",
      ylim=[0.003*abun_max, 1.5*abun_max]
  )
  axes[-2].set(
      xscale="log",
      yscale="symlog",
      #yticks=[-1, 0, 1, 10],
      ylabel="Grain potential, eV",
  )
  axes[-1].set(
      xscale="log",
      yscale="log",
      xlabel="Radius, pc",
      ylabel="Drift velocity, km/s"
  )
  fig.suptitle(PREFIX, y=0.99)
  sns.despine()
  fig.tight_layout(h_pad=0.1)
  fig.savefig(pltfile, dpi=300)
#+END_SRC

#+RESULTS: make-plot
[[file:models/test-dust-tlusty.png]]


#+call: make-plot(PREFIX="dustrad-n03-MS10")

#+RESULTS:
[[file:models/dustrad-n03-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n03-MS40")

#+RESULTS:
[[file:models/dustrad-n03-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS10")

#+RESULTS:
[[file:models/dustrad-n00-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n00-BSG")

#+RESULTS:
[[file:models/dustrad-n00-BSG.png]]

#+call: make-plot(PREFIX="dustrad-n01-BSG")

#+RESULTS:
[[file:models/dustrad-n01-BSG.png]]

#+call: make-plot(PREFIX="dustrad-n04-BSG")

#+RESULTS:
[[file:models/dustrad-n04-BSG.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS10")

#+RESULTS:
[[file:models/dustrad-n04-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS20")

#+RESULTS:
[[file:models/dustrad-n04-MS20.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS40")

#+RESULTS:
[[file:models/dustrad-n04-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS40")

#+RESULTS:
[[file:models/dustrad-n00-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS20")

#+RESULTS:
[[file:models/dustrad-n04-MS20.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS20")

#+RESULTS:
[[file:models/dustrad-n00-MS20.png]]

#+call: make-plot(PREFIX="dustrad-n01-MS10")

#+RESULTS:
[[file:models/dustrad-n01-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n02-MS10")

#+RESULTS:
[[file:models/dustrad-n02-MS10.png]]


* Look at continuum spectrum 
+ Saving every zone should be unnecessary
  - we can just look at the incident and transmitted continuum for the last zone
  - Since we don't go into the PDR much, this should be representative of the FUV and EUV attenuation throughout the nebula
#+name: make-sed
#+header: :var PREFIX="dustrad-n00-MS40"
#+BEGIN_SRC python :return pltfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'spectra-{PREFIX}.pdf'
  m = CloudyModel(f'models/{PREFIX}')

  fig, ax = plt.subplots()

  nu = m.data['cont']['Cont  nu']
  nuFnu_inc = m.data['cont']['incident'] 
  nuFnu_trans = m.data['cont']['trans'] 
  nuFnu_tot = m.data['cont']['total'] 
  vmax = nuFnu_inc.max()
  ax.plot(nu, nuFnu_inc)
  ax.plot(nu, nuFnu_tot, lw=0.6)
  ax.plot(nu, nuFnu_trans, lw=0.3)

  L_bol = np.trapz(nuFnu_inc/nu, nu)
  mfuv = (nu >= 912.0/2000.0) & (nu <= 1.0)
  meuv = (nu > 1.0) & (nu <= 4.0)
  L_fuv = np.trapz(nuFnu_inc[mfuv]/nu[mfuv], nu[mfuv])
  L_euv = np.trapz(nuFnu_inc[meuv]/nu[meuv], nu[meuv])

  ax.axvspan(912.0/2000.0, 1.0, color='0.9')
  ax.axvspan(1.0, 4.0, color='0.95')

  ax.text(0.6, 2e-4*vmax, f"FUV\n{100*L_fuv/L_bol:.1f}%")
  ax.text(1.5, 2e-4*vmax, f"EUV\n{100*L_euv/L_bol:.1f}%")
  ax.set(
      xlim=[0.05, 4.0],
      ylim=[1e-6*vmax, 2.*vmax],
      yscale='log',
      xscale='log',
      xlabel='Photon energy, Rydberg',
      ylabel=r'$\nu F_{\nu}$',
  )

  fig.savefig(pltfile)

#+END_SRC

#+RESULTS: make-sed
[[file:spectra-dustrad-n00-MS40.pdf]]


#+call: make-sed(PREFIX="dustrad-n04-MS40")

#+RESULTS:
[[file:spectra-dustrad-n04-MS40.pdf]]

#+call: make-sed(PREFIX="dustrad-n00-BSG")

#+RESULTS:
[[file:spectra-dustrad-n00-BSG.pdf]]

#+call: make-sed(PREFIX="dustrad-n04-BSG")

#+RESULTS:
[[file:spectra-dustrad-n04-BSG.pdf]]

#+call: make-sed(PREFIX="dustrad-n04-MS10")

#+RESULTS:
[[file:spectra-dustrad-n04-MS10.pdf]]

#+call: make-sed(PREFIX="dustrad-n00-MS10")

#+RESULTS:
[[file:spectra-dustrad-n00-MS10.pdf]]

#+call: make-sed(PREFIX="dustrad-n00-MS20")

#+RESULTS:
[[file:spectra-dustrad-n00-MS20.pdf]]

#+call: make-sed(PREFIX="dustrad-n04-MS20")

#+RESULTS:
[[file:spectra-dustrad-n04-MS20.pdf]]

** Save continuum every zone
+ I am testing saving this every zone so I can find FUV and EUV flux vs radius
  + This makes an enormous file!
    :   -rw-r--r--   1 will staff 247M Mar 17 23:58  test-dust-tlusty.cont
+ Seems to be no way to get Cloudy to save flux in a band as function of depth
+ For this example run (MS10 low density), the FUV is not absorbed at all because the ionization parameter is low, so dust \tau is negligible

#+header: :var PREFIX="test-dust-tlusty"
#+BEGIN_SRC python :return pltfile :results file
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'fluxes-{PREFIX}.pdf'
  m = CloudyModel(f'models/{PREFIX}')

  # Split spectrum into a list of tables, one for each spatial zone
  nzones = len(m.data['ovr'])
  split_tabs = [Table(t) for t in np.split(m.data['cont'].as_array(), nzones)]

  fig, ax = plt.subplots()

  for tab in split_tabs[::10]:
      ax.plot(tab['Cont  nu'], tab['trans'])

  ax.set(
      xlim=[0.1, 10.0],
      ylim=[1e25, 1e37],
      yscale='log',
      xscale='log',
      xlabel='Photon energy, Rydberg',
      ylabel='Flux',
  )

  fig.savefig(pltfile)

#+END_SRC

#+RESULTS:
[[file:fluxes-test-dust-tlusty.pdf]]

* An Emacs mode for cloudy input files
Cloudy has now changed it's comment character, so I needed to revisit this
#+BEGIN_SRC emacs-lisp
  (require 'generic-x) ;; we need this

  (define-generic-mode 
      'cloudy-input-mode                         ;; name of the mode to create
    '("#")                           ;; comments start with '#'
    '("set" "stop" "hden" "table" "blackbody" "title" "element" "constant" "cmb" 
      "print" "save" "iterate" "time" "end" "cosmic ray" "coronal" "phi(h)"
      "abundances" "luminosity" "table")                     ;; some keywords
    '(("\\(#\\($\\| .*\\)\\)" 1 'font-lock-comment-face t)
      ("\\(//\\($\\| .*\\)\\)" 1 'font-lock-comment-face t)
      ("=" . 'font-lock-operator-face)     ;; '=' is an operator
      ("\\b\\(scale\\|log\\|linear\\|file\\|units\\)\\b" . 'font-lock-constant-face)     
      ("\\b\\(no\\|end\\|stop\\)\\b" 1 'font-lock-negation-char-face t)     
      ("^title \\(.*\\)$" 1 'font-lock-doc-face t)     
      ("^$" 1 'show-tabs-tab t)
      ("

  \\(.*\\)$" 1 'font-lock-doc-face t)     
      )     ;; 
    '("\\.in$")                      ;; files for which to activate this mode 
    nil                              ;; other functions to call
    "A mode for Cloudy input files"            ;; doc string for this mode
    )
#+END_SRC

#+RESULTS:
: cloudy-input-mode
