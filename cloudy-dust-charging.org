* Cloudy models of dust grain charging around luminous stars
+ The aim is to find \phi as a function of ionization parameter (and other parameters)
  + Mainly for OB stars, but may also try RSG/AGB case
+ This can then be used to study gas-grain decoupling in bow shocks
* DONE Initial tests
CLOSED: [2018-03-16 Fri 10:55]
+ [X] Write an input file by hand
  + Start with something from test suite?
  + First attempt is [[file:models/test-dust.in]]
+ [X] Run it and see what output we need to save
  #+BEGIN_SRC sh :eval no
  export D=~/Work/CLOUDY/cloudy/source
  cd models
  $D/cloudy.exe -p test-dust
  #+END_SRC


* TODO Production runs
+ [X] Decide which approach to use?
  1. Python script to write multiple input, run with ~make -j 8~
  2. Work out how to use Cloudy grid command (need to install MPI?)
+ Do it


* Expand template for input files
#+BEGIN_SRC python
  from textwrap import dedent
  import numpy as np

  def star_input(id_, L_Lsun, T3, log_g):
      s = f"# {id_} star" + "\n"
      s += f"table star tlusty OBstar 3-dim {1e3*T3:.0f} {log_g} 0.0" + "\n"
      s += f"luminosity {np.log10(3.82e33*L_Lsun):.2f}" + "\n"
      return s

  def hden_input(hden):
      return f"hden {hden:.2f} # density of {10**hden} pcc" + "\n"

  def file_stem(hden, id_):
      return f"dustrad-n{int(hden):02d}-{id_}" 

  def intro_input(hden, id_):
      s = f"title Dust radiative acceleration: star {id_}, density {10**hden} pcc" + "\n"
      s += f"set save prefix \"{file_stem(hden, id_)}\"" + "\n"
      return s

  stars = [
      # id_  L_Lsun  T3    log_g
      ["MS10", 0.63, 25.2, 4.2],
      ["MS20", 5.45, 33.9, 4.2],
      ["MS40", 22.2, 42.5, 4.2],
      ["BSG",  30.2, 23.5, 3.4],
  ]

  def radius_input(L_Lsun, hden):
      # Scale R_in to give same F_bol / N as the MS10 model with hden=1
      R_in = 3e15 * np.sqrt((L_Lsun/0.63) * 10**(1.0 - hden))
      s = f"# Start close in: {R_in/3.085677582e18:.5f} pc" + "\n"
      s += f"radius {np.log10(R_in)}" + "\n"
      return s


  outro_input = dedent("""\
  # Go into PDR a bit
  stop temperature 1000 K linear
  stop efrac 0.001
  stop Lyman optical depth = 5
  iterate
  sphere
  abundances HII region
  cosmic ray background
  cmb
  # save all the output we want
  save overview last ".ovr"
  save physical conditions last ".phys"
  save continuum last ".cont"
  save radius last ".rad"
  save interactive continuum last ".icont"
  save grain charge last ".gcharge"
  save grain continuum last ".gcont"
  save grain drift velocity last ".gdrift"
  save grain potential last ".gpot"
  save grain temperature last ".gtemp"
  """)


  for hden in 0.0, 1.0, 2.0, 3.0, 4.0:
      for id_, L_Lsun, T3, log_g in stars:
          cloudy_input = (intro_input(hden, id_)
                          + star_input(id_, L_Lsun, T3, log_g)
                          + hden_input(hden)
                          + radius_input(L_Lsun, hden)
                          + outro_input)
          file_name = f"models/{file_stem(hden, id_)}.in"
          with open(file_name, "w") as f:
              f.write(cloudy_input)
#+END_SRC

#+RESULTS:
: None


* Look at dust 

* Graphs

** Utility library for reading model
#+BEGIN_SRC python :tangle cloudytab.py
  from astropy.table import Table
  import glob

  # File extensions that might be present, but which are NOT Cloudy save files
  IGNORE_EXTS = ["pdf", "png", "jpg"]

  class CloudyModel(object):
      """Lightweight wrapper for output from Cloudy run 

      For example:

      >>> from cloudytab import CloudyModel
      >>> m = CloudyModel("myfolder/mymodel")

      `m.files` contains a list of all the files that were found: 
                `['myfolder/mymodel.in', 'myfolder/mymodel.ovr', ETC]`

      `m.data` contains dict of astropy.Table's, one for each save file:
                `{'ovr': <Table length=289> ..., ETC}`

      `m.io['in']` and `m.io['out']` contain the input and output streams
      """
      def __init__(self, prefix):
          self.files = glob.glob(prefix + ".*")
          self.data = {}
          self.io = {}
          for file_ in self.files:
              saveid = file_.split(".")[-1]
              if saveid in IGNORE_EXTS:
                  # Figure files, etc need to be skipped
                  pass
              elif saveid in ["in", "out"]:
                  # Special case of input and output files
                  with open(file_) as f:
                      # Just save the whole file as a string
                      self.io[saveid] = f.read()
              else:
                  # Assume all else are save files
                  try:
                      self.data[saveid] = Table.read(
                          file_, delimiter="\t",
                          format="ascii.commented_header")
                  except UnicodeDecodeError:
                      # Binary files can raise this error - ignore them
                      pass

#+END_SRC


** Try plotting a bunch of models: potential versus ionization parameter
+ Estimate ionization parameter from H neutral fraction 
+ Do a single star at a time, since there may be a secondary dependence on the spectral shape
#+name: phi-vs-ipar
#+header: :var STAR="MS10" GRAIN="sil-orion01"
#+BEGIN_SRC python :return figfile :results file
  import glob
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  figfile = f"phi-ipar-{STAR}-{GRAIN}.pdf"

  infiles = glob.glob(f"models/dustrad-*-{STAR}.in")
  models = []
  for infile in infiles:
      prefix = infile.replace(".in", "")
      modelid = prefix.replace("models/dustrad-", "")  # e.g., n03-MS10
      models.append([modelid, CloudyModel(prefix)])


  fig, ax = plt.subplots()
  for label, m in sorted(models):
      # Ionization parameter, estimated as x^2 / (1 - x)
      # (Initially, we neglect correction for alpha(T) and sigma(tau))
      ipar = m.data["ovr"]["HII"]**2 / m.data["ovr"]["HI"]
      # Grain potential divided by kT
      gpot = m.data["gpot"][GRAIN]*u.eV / (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)

      ax.plot(ipar, gpot, label=label)
  ax.axvspan(0.0111, 8.1, color='k', alpha=0.1)    # x = 0.1 -> 0.9
  ax.axhspan(-1.0, 1.0, color='k', alpha=0.1)      # |phi| < 1
  ax.legend(title=GRAIN)
  ax.set(
      xscale='log',
      yscale='symlog',
      xlabel="Ionization parameter",
      ylabel="Grain potential / k T",
      xlim=[3e-5, 3e6],
      ylim=[-5.0, 50.0],
  )
  sns.despine()

  fig.savefig(figfile)
#+END_SRC

#+RESULTS: phi-vs-ipar
[[file:phi-ipar-MS10-sil-orion01.pdf]]

#+call: phi-vs-ipar("MS10", "sil-orion10")

#+RESULTS:
[[file:phi-ipar-MS10-sil-orion10.pdf]]

#+call: phi-vs-ipar("MS10", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-MS10-gra-orion10.pdf]]

#+call: phi-vs-ipar("MS40", "sil-orion01")

#+RESULTS:
[[file:phi-ipar-MS40-sil-orion01.pdf]]

#+call: phi-vs-ipar("MS40", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-MS40-gra-orion10.pdf]]

#+call: phi-vs-ipar("BSG", "gra-orion10")

#+RESULTS:
[[file:phi-ipar-BSG-gra-orion10.pdf]]


#+name: phi-vs-ipar-allgrain
#+header: :var STAR="MS10" 
#+BEGIN_SRC python :return figfile :results file
  import glob
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  figfile = f"phi-ipar-{STAR}-allgrain.pdf"

  infiles = glob.glob(f"models/dustrad-*-{STAR}.in")
  models = []
  for infile in infiles:
      prefix = infile.replace(".in", "")
      modelid = prefix.replace("models/dustrad-", "")  # e.g., n03-MS10
      models.append([modelid, CloudyModel(prefix)])


  fig, ax = plt.subplots()
  colors = sns.color_palette(palette="magma_r", n_colors=len(models))
  for color, [label, m] in zip(colors, sorted(models)):
      # Ionization parameter, estimated as x^2 / (1 - x)
      # (Initially, we neglect correction for alpha(T) and sigma(tau))
      ipar = m.data["ovr"]["HII"]**2 / m.data["ovr"]["HI"]

      for grain in m.data["gpot"].colnames[1:]:
          # Grain potential divided by kT
          gpot = m.data["gpot"][grain]*u.eV / (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)
          ls = '--' if grain.startswith("gra") else '-'
          ax.plot(ipar, gpot, alpha=0.8, color=color, ls=ls, lw=0.3)
          m2 = m.data["gdrift"][grain] >= 5.0
          m1 = (m.data["gdrift"][grain] >= 0.5) & ~m2
          ax.scatter(ipar[m2], gpot[m2],
                     marker='.', alpha=0.6, color='c', edgecolors='none')
          ax.scatter(ipar[m1], gpot[m1],
                     marker='.', alpha=0.6, color='g', edgecolors='none')

  ax.axvspan(0.0111, 8.1, color='k', alpha=0.1)    # x = 0.1 -> 0.9
  ax.axhspan(-1.0, 1.0, color='k', alpha=0.1)      # |phi| < 1
  #ax.legend(title=GRAIN)
  ax.set(
      xscale='log',
      yscale='symlog',
      xlabel="Ionization parameter",
      ylabel="Grain potential / k T",
      xlim=[3e-5, 3e6],
      ylim=[-5.0, 50.0],
  )
  sns.despine()

  fig.savefig(figfile)
#+END_SRC

#+RESULTS: phi-vs-ipar-allgrain
[[file:phi-ipar-MS10-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("MS20")

#+RESULTS:
[[file:phi-ipar-MS20-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("MS40")

#+RESULTS:
[[file:phi-ipar-MS40-allgrain.pdf]]

#+call: phi-vs-ipar-allgrain("BSG")

#+RESULTS:
[[file:phi-ipar-BSG-allgrain.pdf]]

** Multi-panels for a single run
#+name: make-plot
#+header: :var PREFIX="test-dust-tlusty"
#+BEGIN_SRC python :return pltfile :results file :exports both
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy import units as u
  from astropy.constants import k_B
  from cloudytab import CloudyModel

  pltfile = f'models/{PREFIX}.png'
  m = CloudyModel(f'models/{PREFIX}')

  sns.set_palette("Reds_d", n_colors=10)
  sns.set_color_codes()
  fig, axes = plt.subplots(4, 1, sharex=True, figsize=(6, 9))
  radius_pc = (m.data["rad"]["radius"])*u.cm.to(u.pc)
  kT_eV = (m.data["ovr"]["Te"]*u.K*k_B).to(u.eV)

  for gtype in m.data["gdrift"].colnames[1:]:
      if gtype.startswith('sil'):
          style = dict(lw=1.0, alpha=0.6, ls='-')
      else:
          style = dict(lw=0.6, alpha=1.0, ls='--')
      axes[-1].plot(radius_pc, m.data["gdrift"][gtype], label=gtype, **style)
      axes[-2].plot(radius_pc, m.data["gpot"][gtype], label=gtype, **style)
      axes[0].plot(radius_pc, m.data["gtemp"][gtype], label=gtype, **style)

  axes[0].plot(radius_pc, m.data["ovr"]["Te"], color='g')
  axes[1].plot(radius_pc, m.data["phys"]["accel"], color='r')


  axes[-2].plot(radius_pc, kT_eV)
  axes[-2].axhline(0.0, color='0.5', lw=0.5)
  axes[-1].legend(ncol=2, loc="lower left", fontsize="xx-small")
  axes[0].set(
      xscale="log",
      yscale="log",
      ylabel="Temperature, K",
      ylim=[0, None],
  )
  axes[1].set(
      yscale="log",
      ylabel="Acceleration",
  )
  axes[-2].set(
      xscale="log",
      yscale="symlog",
      #yticks=[-1, 0, 1, 10],
      ylabel="Grain potential, eV",
  )
  axes[-1].set(
      xscale="log",
      yscale="log",
      xlabel="Radius, pc",
      ylabel="Drift velocity, km/s"
  )
  fig.suptitle(PREFIX, y=0.99)
  sns.despine()
  fig.tight_layout(h_pad=0.1)
  fig.savefig(pltfile, dpi=300)
#+END_SRC

#+RESULTS: make-plot
[[file:models/test-dust-tlusty.png]]


#+call: make-plot(PREFIX="dustrad-n03-MS10")

#+RESULTS:
[[file:models/dustrad-n03-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n03-MS40")

#+RESULTS:
[[file:models/dustrad-n03-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS10")

#+RESULTS:
[[file:models/dustrad-n00-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n00-BSG")

#+RESULTS:
[[file:models/dustrad-n00-BSG.png]]

#+call: make-plot(PREFIX="dustrad-n04-BSG")

#+RESULTS:
[[file:models/dustrad-n04-BSG.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS10")

#+RESULTS:
[[file:models/dustrad-n04-MS10.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS20")

#+RESULTS:
[[file:models/dustrad-n04-MS20.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS40")

#+RESULTS:
[[file:models/dustrad-n04-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS40")

#+RESULTS:
[[file:models/dustrad-n00-MS40.png]]

#+call: make-plot(PREFIX="dustrad-n04-MS20")

#+RESULTS:
[[file:models/dustrad-n04-MS20.png]]

#+call: make-plot(PREFIX="dustrad-n00-MS20")

#+RESULTS:
[[file:models/dustrad-n00-MS20.png]]


* An emacs mode for cloudy input files
Cloudy has now changed it's comment character, so I needed to revisit this
#+BEGIN_SRC emacs-lisp
  (require 'generic-x) ;; we need this

  (define-generic-mode 
      'cloudy-input-mode                         ;; name of the mode to create
    '("#")                           ;; comments start with '#'
    '("set" "stop" "hden" "table" "blackbody" "title" "element" "constant" "cmb" 
      "print" "save" "iterate" "time" "end" "cosmic ray" "coronal" "phi(h)"
      "abundances" "luminosity" "table")                     ;; some keywords
    '(("\\(#\\($\\| .*\\)\\)" 1 'font-lock-comment-face t)
      ("\\(//\\($\\| .*\\)\\)" 1 'font-lock-comment-face t)
      ("=" . 'font-lock-operator-face)     ;; '=' is an operator
      ("\\b\\(scale\\|log\\|linear\\|file\\|units\\)\\b" . 'font-lock-constant-face)     
      ("\\b\\(no\\|end\\|stop\\)\\b" 1 'font-lock-negation-char-face t)     
      ("^title \\(.*\\)$" 1 'font-lock-doc-face t)     
      ("^$" 1 'show-tabs-tab t)
      ("

  \\(.*\\)$" 1 'font-lock-doc-face t)     
      )     ;; 
    '("\\.in$")                      ;; files for which to activate this mode 
    nil                              ;; other functions to call
    "A mode for Cloudy input files"            ;; doc string for this mode
    )
#+END_SRC

#+RESULTS:
: cloudy-input-mode
